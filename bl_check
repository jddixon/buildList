#!/usr/bin/python3
# ~/dev/py/buildlist/bl_check

import os
import sys

from argparse import ArgumentParser
from nlhtree import NLHTree
from xlattice import (check_using_sha,
                      parse_using_sha, fix_using_sha, show_using_sha, check_u_path)
from xlattice.util import get_exclusions, make_ex_re

from buildlist import __version__, __version_date__, BuildList


def check_build_list(args):

    data_dir = args.data_dir  # _without_ trailing slash
    ex_re = make_ex_re(args.excl)
    list_file = args.list_file
    verbose = args.verbose
    u_path = args.u_path
    using_sha = args.using_sha

    if data_dir and data_dir[-1] == '/':      # trailing slash
        data_dir = data_dir[:-1]
    if u_path and u_path[-1] == '/':          # trailing slash
        u_path = u_path[:-1]

    blist = None
    data = None
    ok_ = False
    signed = False

    try:
        # can't use 'r' which converts CRLF to just LF
        with open(list_file, 'rb') as file:
            data = file.read()
            ok_ = True     # no exceptions
    except Exception as exc:
        print("error reading build list file: '%s'" % exc)

    if ok_:
        ok_ = False
        try:
            blist = BuildList.parse(data, using_sha)
            ok_ = True
        except Exception as exc:
            print("error parsing BuildList: '%s'" % exc)

    if ok_:
        signed = blist.signed
        if signed:
            ok_ = blist.verify
            if not ok_:
                print("dig sig verification fails")

    if ok_:
        using_sha = blist.using_sha
        # assume ex_re can be ignored
        my_tree = NLHTree.create_from_file_system(data_dir, using_sha, ex_re)
        ok_ = my_tree == blist.tree
        if not ok_:
            print("build list's NLHTree doesn't match %s" % data_dir)
            print("NLHTree for %s:\n%s" % (data_dir, my_tree))
            print("NLHTree for BuildList:\n%s" % blist.tree)

    if ok_ and u_path:
        unmatched = blist.tree.check_in_u_dir(u_path)
        if unmatched:
            print("BuildList, data_dir, and u_path are inconsistent")
            for unm in unmatched:
                print("  %s is in the tree but not found in u_path" % unm)

    if ok_:
        print("ok_")


def main():
    """
    Expect a command like
        bl_check [options]

    """

    # parse the command line ----------------------------------------

    desc = 'verify integrity of build list, optionally agains root dir and u_path"'
    parser = ArgumentParser(description=desc)

    parser.add_argument('-b', '--list_file',
                        help='root directory for build list')

    parser.add_argument('-d', '--data_dir',
                        help='root directory for build list')

    parser.add_argument('-i', '--ignore_file', default='.gitignore',
                        help='file containing wildcards (globs) for files to ignore')

    parser.add_argument('-j', '--just_show', action='store_true',
                        help='show options and exit')

    # -1,-2,-3, using_sha, -v/--verbose
    parse_using_sha(parser)

    args = parser.parse_args()

    # fixups --------------------------------------------------------

    fix_using_sha(args)

    args.cur_dir = os.getcwd()
    if os.path.exists(args.ignore_file):
        args.excl = get_exclusions(args.cur_dir)
    else:
        print("WARNING: ignore file '%s' NOT FOUND" % args.ignore_file)
        args.excl = []
    if not 'build' in args.excl:
        args.excl.append('build')

    # sanity checks -------------------------------------------------
    check_using_sha(args.using_sha)
    if (not args.just_show):
        if not args.list_file or not os.path.isfile(args.list_file):
            print("list file %s does not exist" % args.list_file)
            parser.print_usage()
            sys.exit(1)

        if (not args.data_dir) or (args.data_dir == ''):
            print("no root directory specified")
            parser.print_usage()
            sys.exit(1)

        if not os.path.isdir(args.data_dir):
            print("root directory %s does not exist" % args.data_dir)
            parser.print_usage()
            sys.exit(1)

        check_u_path(parser, args, mustExist=True)

    # complete setup ------------------------------------------------
    app_name = 'bl_check %s' % __version__

    # maybe show options and such -----------------------------------
    if args.verbose or args.just_show:
        print("%s %s" % (app_name, __version_date__))

    if args.verbose or args.just_show:
        print('data_dir      = ' + str(args.data_dir))
        print('ignore_file   = ' + str(args.ignore_file))
        print('list_file     = ' + str(args.list_file))
        show_using_sha(args)

    if args.just_show:
        sys.exit(0)

    # do what's required --------------------------------------------
    check_build_list(args)


if __name__ == '__main__':
    main()
