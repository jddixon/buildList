#!/usr/bin/python3
from xlattice import Q
#
# ~/dev/py/buildList/blBootstrap

import os
import re
import shutil
import sys

from argparse import ArgumentParser
from Crypto.PublicKey import RSA
from nlhtree import NLHLeaf, NLHTree
from xlattice.lfs import touch
from xlattice.util import make_ex_re
from rnglib import SimpleRNG
from xlattice import Q, check_using_sha

from buildList import __file__, BuildList


def do_it(args):
    exDir = args.exDir
    print("This will destroy %s1, %s2, and %s2" % (exDir, exDir, exDir))
    ok = input("OK to proceed? (Y/n)")
    if ok:
        ok = ok.capitalize()
        if not ok.startswith('Y'):
            sys.exit(0)

    for using in [Q.USING_SHA1, Q.USING_SHA2, Q.USING_SHA3, ]:
        reallyDoIt(args, using)


def reallyDoIt(args, using_sha):
    check_using_sha(using_sha)
    exDir = args.exDir
    if using_sha == Q.USING_SHA1:
        exDir += '1'
    elif using_sha == Q.USING_SHA2:
        exDir += '2'
    elif using_sha == Q.USING_SHA3:
        exDir += '3'
    force = args.force
    verbose = args.verbose

    dataDir = os.path.join(exDir, 'dataDir')
    listFile = os.path.join(exDir, 'example.bld')
    nodeDir = os.path.join(exDir, 'node')
    title = 'sample build list'
    u_path = os.path.join(exDir, 'u_dir')

    uTmp = os.path.join(u_path, 'tmp')

    if os.path.exists(exDir):
        print("deleting existing directory %s" % exDir)
        shutil.rmtree(exDir)

    subDir1 = os.path.join(dataDir, 'subDir1')
    subDir2 = os.path.join(dataDir, 'subDir2')
    subDir3 = os.path.join(dataDir, 'subDir3')
    subDir4 = os.path.join(dataDir, 'subDir4')
    subDir41 = os.path.join(subDir4, 'subDir41')
    subDir411 = os.path.join(subDir41, 'subDir411')

    for dVal in [dataDir, nodeDir, u_path, uTmp]:
        os.makedirs(dVal, mode=0o755)
    for dVal in [subDir1, subDir2, subDir3, subDir4]:
        os.makedirs(dVal, mode=0o755)
    os.makedirs(subDir41, mode=0o755)
    os.makedirs(subDir411, mode=0o755)

    # files to be populaed with random data
    rng = SimpleRNG()
    data1 = os.path.join(dataDir, 'data1')
    data11 = os.path.join(subDir1, 'data11')
    data2 = os.path.join(dataDir, 'data2')
    data31 = os.path.join(subDir3, 'data31')
    data4111 = os.path.join(subDir411, 'data31')

    for path in [data1, data11, data2, data31, data4111]:
        count = 16 + rng.nextInt16(2048)
        data = bytearray(count)
        rng.nextBytes(data)
        with open(path, 'wb') as file:
            file.write(data)

    # empty file(s)
    data12 = os.path.join(subDir1, 'data12')
    for path in [data12]:
        touch(path)

    # should be >= 2048, but this is just testing
    skPriv = RSA.generate(1024)
    pathToKey = os.path.join(nodeDir, "skPriv.pem")
    with open(pathToKey, 'wb') as file:
        file.write(skPriv.exportKey('PEM'))
    sk = skPriv.publickey()

    exRE = make_ex_re(['build', ])
    bl = BuildList.create_from_file_system(title, dataDir, sk, using_sha,
                                           exRE, matchRE=None)
    bl.sign(skPriv)
    blSer = bl.toString()
    with open(listFile, 'w') as file:
        file.write(blSer)

    # XXX WORKING HERE

    # XXX need checks on uPath

    bl.tree.save_to_u_dir(dataDir, u_path, using_sha=using_sha)
    unmatched = bl.tree.check_in_u_dir(u_path)    # all leaf nodes present ?
    if unmatched:
        print("check walk on example/ failed")
        for u in unmatched:
            print("  %s is not in uDir" % u)


def main():
    """
    Expect a command like
        blBootstrap [options]

    This program creates three directory tree like

        exampleN/               # where N is 1 or 2 or 3
            node                # was .xlattice
                skPriv          # PEM serialization
            dataDir/
                data1
                subDir1/
                    data11
                    data12      # empty
                data2
                subDir2/
                subDir3/
                    data31
                subDir4/
                    subDir41
                        subDir411
                            data4111
            dataDir.bld
            uDir/
                00
                ...
                ff
                tmp/

    The example1 directory uses SHA1; example2 uses SHA2 aka SHA-256,
    and example3 uses SHA3, aka SHA3-256 aka KECCAK-256.

    skPriv is the RSA private key used to sign the example.bld
    build list.

    The information under exampleN/dataDir is a small directory tree.
    The data* are data files containing quasi-random data.  Both the
    file length and the contents are random.  data12 is an empty file.
    Subdirectory subDir2 is an empty subdirectory.

    dataDir.bld is a build list for dataDir.  The build list contains
    the public part of the RSA key used to sign the list, its title,
    and a UTC timestamp, the time at which the list was signed.  The
    body of the list is an indented list of the files under dataDir/,
    with a line for each file, each line containing the SHA content
    hash of the document and its title.  The build list ends with a
    digital signature over the earlier part of the document.  In this
    example, the RSA private key used in signing the document in
    contained in node/skPriv.

    uDir/ contains the same set of files as under dataDir/, but
    instead of being organized by name it is organized by content
    key, by the SHA1 hash of the file.

    The data under exampleN/ is sufficient to verify the correctness of
    the build list and the 1-to-1 relationship between the files under
    exampleN/datadir/ and those under exampleN/uDir/

    """
    __version__ = re.search("__version__\s*=\s*'(.*)'",
                            open(__file__).read()).group(1)
    __version_date__ = re.search("__version_date__\s*=\s*'(.*)'",
                                 open(__file__).read()).group(1)

    # parse the command line ----------------------------------------

    DESC = 'generate a sample data tree, write a build list, and create a corresponding content-keyed store'

    parser = ArgumentParser(description=DESC)

    parser.add_argument('-e', '--exDir', default='example',
                        help='example directory, defaults to example/')

    parser.add_argument('-f', '--force', action='store_true',
                        help='overwrite any existing example/ directory')

    parser.add_argument('-j', '--justShow', action='store_true',
                        help='show options and exit')

    parser.add_argument('-v', '--verbose', action='store_true',
                        help='be chatty')

    args = parser.parse_args()

    # sanity chesks -------------------------------------------------
    if args.exDir[0] == '/':
        print("example dir must not be absolute path")
        parser.print_usage()
        sys.exit(1)
    if args.exDir[0] == '.':
        print("example dir name must not begin with dot ('.')")
        parser.print_usage()
        sys.exit(1)

    if (not args.force) and os.path.exists(args.exDir):
        print(
            "example directory %s exists but force (-f) not specified" %
            args.exDir)
        parser.print_usage()
        sys.exit(1)

    # fixups --------------------------------------------------------

    # complete setup ------------------------------------------------
    appName = 'blBootstrap %s' % __version__

    # maybe show options and such -----------------------------------
    if args.verbose or args.justShow:
        print("%s %s" % (appName, __version_date__))

    if args.verbose or args.justShow:
        print('exDir        = ' + str(args.exDir))
        print('force        = ' + str(args.force))
        print('verbose      = ' + str(args.verbose))

    if args.justShow:
        sys.exit(0)

    # do what's required --------------------------------------------
    do_it(args)

if __name__ == '__main__':
    main()
