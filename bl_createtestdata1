#!/usr/bin/python3
# ~/dev/py/buildlist/bl_createtestdata1

""" Create test data for interoperability tests. """

from argparse import ArgumentParser
import os
import shutil
import sys

from buildlist import __version__, __version_date__, BuildList
from Crypto.PublicKey import RSA
from nlhtree import NLHTree
from rnglib import SimpleRNG
from xlattice import QQQ
from xlattice.lfs import touch
from xlattice.u import UDir
from xlattice.util import make_ex_re
#from xlattice import check_using_sha

DEFAULT_OUT_DIR = '../../dat/xl_test_data/treeData/binExample_1'


def create_test_dir_and_node(args):
    """
    Create test directory and its node/ subdir with an RSA private key,
    each unless it already exists.
    """

    out_path = args.out_path
    if os.path.exists(out_path) and args.force:
        print("deleting existing directory %s" % out_path)
        shutil.rmtree(out_path)

    # creates ../xl_test_data/treeData/binExample_1 if it doesn't exist
    os.makedirs(out_path, exist_ok=True)

    # for using in [QQQ.USING_SHA1, QQQ.USING_SHA2, QQQ.USING_SHA3, ]:

    # NODE_DIR ------------------------------------------------------
    # Creates RSA key sk_priv and its public part sk; and writes
    # node/skPriv.pem.
    # ---------------------------------------------------------------
    node_dir = os.path.join(out_path, 'node')
    os.makedirs(node_dir, mode=0o755, exist_ok=True)

    path_to_key = os.path.join(node_dir, 'skPriv.pem')
    if os.path.exists(path_to_key):
        # if a key file exists, use it
        with open(path_to_key, 'rb') as file:
            # XXX possible exception
            sk_priv = RSA.importKey(file.read())
    else:
        sk_priv = RSA.generate(2048)
        with open(path_to_key, 'wb') as file:
            file.write(sk_priv.exportKey('PEM'))
    return out_path, sk_priv


def create_core_data_dir(out_path):
    """
    Create any core data files and subdirectories that do not
    already exist.
    """

    data_path = os.path.join(out_path, 'dataDir')
    sub_dir1 = os.path.join(data_path, 'subDir1')
    sub_dir2 = os.path.join(data_path, 'subDir2')
    sub_dir3 = os.path.join(data_path, 'subDir3')
    sub_dir4 = os.path.join(data_path, 'subDir4')
    sub_dir41 = os.path.join(sub_dir4, 'subDir41')
    sub_dir411 = os.path.join(sub_dir41, 'subDir411')

    for dir_name in [data_path, sub_dir1, sub_dir2, sub_dir3, sub_dir4,
                     sub_dir41, sub_dir411, ]:
        os.makedirs(dir_name, mode=0o755, exist_ok=True)

    # files to be populaed with random data
    rng = SimpleRNG()
    data1 = os.path.join(data_path, 'data1')
    data11 = os.path.join(sub_dir1, 'data11')
    data2 = os.path.join(data_path, 'data2')
    data31 = os.path.join(sub_dir3, 'data31')
    data4111 = os.path.join(sub_dir411, 'data31')

    for path in [data1, data11, data2, data31, data4111]:
        if os.path.exists(path):
            continue
        count = 16 + rng.nextInt16(2048)
        data = bytearray(count)
        rng.nextBytes(data)
        with open(path, 'wb') as file:
            file.write(data)

    # empty file(s)
    data12 = os.path.join(sub_dir1, 'data12')
    for path in [data12]:
        touch(path)
    return data_path


def do_it(args):
    """ Create test data for interoperability tests. """

    out_path, sk_priv = create_test_dir_and_node(args)
    sk_ = sk_priv.publickey()               # public part of key
    data_path = create_core_data_dir(out_path)

    # create derived/ after deleting any existing files and subdirectories
    derived_path = os.path.join(out_path, 'derived')
    if os.path.exists(derived_path):
        shutil.rmtree(derived_path)
    os.mkdir(derived_path, 0o755)

    for using_sha in [QQQ.USING_SHA1, QQQ.USING_SHA2, QQQ.USING_SHA3]:
        ndx = int(using_sha)
        ndx_path = os.path.join(derived_path, 'sha' + str(ndx))
        os.makedirs(ndx_path, mode=0o755)

        # create and serialize the NLHTree
        tree = NLHTree.create_from_file_system(data_path, using_sha)

        # XXX STUB: serialize NLHTree to example.nlh

        # create and serialize the BuildList
        list_file = os.path.join(ndx_path, 'example.bld')
        title = 'sample build list % d' % ndx
        ex_re = make_ex_re(['build', ])
        blist = BuildList.create_from_file_system(
            title, data_path, sk_, using_sha, ex_re, match_re=None)
        blist.sign(sk_priv)
        bl_ser = blist.__str__()
        with open(list_file, 'w+') as file:
            file.write(bl_ser)

        for dir_struc in [UDir.DIR_FLAT, UDir.DIR16x16, UDir.DIR256x256]:
            name = UDir.DIR_STRUC_NAMES[dir_struc]
            struc_path = os.path.join(ndx_path, name)
            os.mkdir(struc_path, 0o755)

            # initialize uDir, create subdirs
            u_path = os.path.join(struc_path, 'uDir')
            u_dir = UDir(u_path, dir_struc, using_sha)
            # save the NLHTree into uDir, populating it
            tree.save_to_u_dir(data_path, u_path, using_sha)


#    # XXX OBSOLETE FROM HERE ========================================
#
#    nlh_path = os.path.join(out_path, 'nlhTree')
#
#    for using_sha in [QQQ.USING_SHA1, QQQ.USING_SHA2, QQQ.USING_SHA3]:
#        ndx = int(using_sha)
#        ndx_path = os.path.join(nlh_path, str(ndx))
#        os.makedirs(ndx_path, mode=0o755, exist_ok=True)
#        tree = NLHTree.create_from_file_system(data_path, using_sha)
#
#        u_path = os.path.join(ndx_path, 'u_dir')
#        u_in = os.path.join(u_path, 'in')
#        u_tmp = os.path.join(u_path, 'tmp')
#        for dir_name in [u_path, u_in, u_tmp]:
#            os.makedirs(dir_name, mode=0o755, exist_ok=True)
#        tree.save_to_u_dir(data_path, u_path, using_sha)
#
#        list_file = os.path.join(ndx_path, 'example.bld')
#        title = 'sample build list % d' % ndx
#        ex_re = make_ex_re(['build', ])
#        blist = BuildList.create_from_file_system(title, data_path, sk_, using_sha,
#                                                  ex_re, match_re=None)
#        blist.sign(sk_priv)
#        bl_ser = blist.__str__()
#        with open(list_file, 'w+') as file:
#            file.write(bl_ser)
#
#    # BUILD LIST ----------------------------------------------------
#    #
#    # ---------------------------------------------------------------
#    bl_path = os.path.join(out_path, 'buildlist')
#
#    for using_sha in [QQQ.USING_SHA1, QQQ.USING_SHA2, QQQ.USING_SHA3]:
#        ndx = int(using_sha)
#        ndx_path = os.path.join(bl_path, str(ndx))
#        os.makedirs(ndx_path, mode=0o755, exist_ok=True)
#
#        list_file = os.path.join(ndx_path, 'example.bld')
#        title = 'sample build list % d' % ndx
#        ex_re = make_ex_re(['build', ])
#        blist = BuildList.create_from_file_system(title, data_path, sk_, using_sha,
#                                                  ex_re, match_re=None)
#        blist.sign(sk_priv)
#        bl_ser = blist.__str__()
#        with open(list_file, 'w+') as file:
#            file.write(bl_ser)
#
#        # XXX MISSING: hex hash of BuildList
#

def main():
    """
    Expect a command like
        bl_createtestdata1 [options]

    This program creates a quasi-random directory tree like

        ../xl_test_data/
            treeData
                binExample.1
                    node
                        skPriv.pem      # PEM serialization of private RSA key
                    dataDir/
                        data1
                        subDir1/
                            data11
                            data12      # empty
                        data2
                        subDir2/
                        subDir3/
                            data31
                        subDir4/
                            subDir41
                                subDir411
                                    data4111
                    derived/
                        sha{1,2,3}/             # three subdirectories
                            struc{Flat,16x16,256x256}
                                uDir/
                                    ...
                                    in/
                                    tmp/
                                example.nlh     # serialization of NLHTree
                                example.bld     # serialized BuildList
                                buildlist.hex   # BuildList.hash()
                                example.merkle  # serialized
                                merkle.hex      # returned by merkleize -x


    sk_priv is the RSA private key used to sign the example.bld
    build list.

    The information under dataDir/ is a small directory tree.
    The data* are data files containing quasi-random data.  Both the
    file length and the contents are random.  data12 is an empty file.
    Subdirectory subDir2 is an empty subdirectory.

    example.bld is a build list for dataDir.  The build list contains
    the public part of the RSA key used to sign the list, its title,
    and a UTC timestamp, the time at which the list was signed.  The
    body of the list is an indented list of the files under dataDir/,
    with a line for each file, each line containing the SHA content
    hash of the document and its title.  The build list ends with a
    digital signature over the earlier part of the document.  In this
    example, the RSA private key used in signing the document in
    contained in node/sk_priv.

    The notation '{1,2,3}' is an abbreviation for "each of the sequence
    of string values 1, 2, and 3, taken in turn."

    Each of derived/sha{1,2,3}/struc{*}/uDir/ includes the set of files
    as dataDir/, but instead of being organized by name the files are
    organized by content key, by the SHA{1,2,3} hash of the files, where
    SHA2 means SHA256 and SHA3 means SHA3-256, the 256-bit version of Keccak.

    That is, the name of each file is its hexadecimal SHA content hash.

    The data under binExample.1/node/ and binExample.1/dataDir is sufficient
    to verify the correctness of
    the build list and the 1-to-1 relationship between the files under
    binExample.1/datadir/ and those under binExample.1/nlhTree/{1,2,3}/uDir/

    For MerkleTrees, there are three serializations, indented lists
    created using SHA1, SHA2, and SHA3 under 1/, 2/, and 3 respectively;
    and also the value returned by merkleize -x, the hash value for the
    entire MerkleTree.
    """

    # parse the command line ----------------------------------------

    desc = 'generate sample data tree, write build list, create corresponding content-keyed store'

    parser = ArgumentParser(description=desc)

    parser.add_argument('-f', '--force', action='store_true',
                        help='destroy any existing test data directory')

    parser.add_argument('-j', '--justShow', action='store_true',
                        help='show options and exit')

    parser.add_argument('-o', '--out_path', default=DEFAULT_OUT_DIR,
                        help="example directory, defaults to '%s'" % DEFAULT_OUT_DIR)

    parser.add_argument('-T', '--testing', action='store_true',
                        help='select if testing')

    parser.add_argument('-v', '--verbose', action='store_true',
                        help='be chatty')

    args = parser.parse_args()

    # fixups --------------------------------------------------------
    if args.testing:
        args.out_path = 'tmp/test_data'

    # sanity chesks -------------------------------------------------

    # complete setup ------------------------------------------------
    app_name = 'bl_createtestdata1 %s' % __version__

    # maybe show options and such -----------------------------------
    if args.verbose or args.justShow:
        print("%s %s" % (app_name, __version_date__))

    if args.verbose or args.justShow:
        print('force        = ' + str(args.force))
        print('out_path     = ' + str(args.out_path))
        print('testing      = ' + str(args.testing))
        print('verbose      = ' + str(args.verbose))

    if args.justShow:
        sys.exit(0)

    # do what's required --------------------------------------------
    do_it(args)

if __name__ == '__main__':
    main()
