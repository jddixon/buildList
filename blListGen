#!/usr/bin/python3
#
# ~/dev/py/buildList/blListGen

import base64
import hashlib
import os
import re
import sys
from argparse import ArgumentParser
from Crypto.PublicKey import RSA
from Crypto.Hash import SHA    # presumably 1

from merkletree import MerkleDoc
from xlattice.util import getExclusions, makeExRE, timestampNow
from buildList import BuildList


def doit(options):
    dataDir = options.dataDir
    dvczDir = options.dvczDir
    excl = options.excl
    keyFile = options.keyFile
    listFile = options.listFile
    logging = options.logging
    title = options.title
    uDir = options.uDir      # if None, don't save to uDir
    usingSHA1 = options.usingSHA1

    bl = BuildList.listGen(title, dataDir, dvczDir, listFile, keyFile,
                    excl, logging, uDir, usingSHA1)

    print("BuildList written to %s" % os.path.join(dvczDir, listFile))

    # confirm that whatever is in the BuildList is now in uDir
    if uDir:
        unmatched = lg.tree.checkInUDir(uDir)
        if unmatched:
            for u in unmatched:
                print("NOT IN UDIR: ", u)


def main():
    """
    Expect a command like
        blListGen [options]

    """

    # program defaults ----------------------------------------------

    NOW = timestampNow()

    __version__ = re.search("__version__\s*=\s*'(.*)'",
                            open('buildList/__init__.py').read()).group(1)
    __version_date__ = re.search("__version_date__\s*=\s*'(.*)'",
                                 open('buildList/__init__.py').read()).group(1)

    appName = 'blListGen %s' % __version__
    APP_NAME = 'blListGen %s' % __version__
    KEY_PATH = os.path.join(os.environ['DVCZ_PATH_TO_KEYS'], 'skPriv.pem')
    UDIR = os.environ['DVCZ_UDIR']

    # parse the command line ----------------------------------------

    DESC = 'generate build list for directory, optionally populating uDir'
    parser = ArgumentParser(description=DESC)

    parser.add_argument('-1', '--usingSHA1', action='store_true',
                        help='use SHA1 in building merkletree (default=false=use SHA256)')

    parser.add_argument('-b', '--listFile', default='lastBuildList',
                        help='path to build list')

    parser.add_argument('-D', '--dvczDir', default='.dvcz',
                        help='dvcz directory (default=.dvcz)')

    parser.add_argument('-d', '--dataDir', default='.',
                        help='data directory for build list (default=./)')

    parser.add_argument('-i', '--ignoreFile', default='.gitignore',
                        help='file containing wildcards (globs) for files to ignore')

    parser.add_argument('-j', '--justShow', action='store_true',
                        help='show options and exit')

    parser.add_argument('-k', '--keyFile', default=KEY_PATH,
                        help='path to RSA private key for signing')

    parser.add_argument('-L', '--logging', action='store_true',
                        help="append timestamp and BuildList hash to to .dvcz/builds")

    # NOT CURRENTLY SUPPORTED (may never be)
    parser.add_argument('-M', '--matchPat', action='append',
                        help='include only files matching this pattern')

    parser.add_argument('-T', '--testing', action='store_true',
                        help='this is a test run')

    parser.add_argument('-t', '--title',
                        help='title for build list')

    parser.add_argument('-u', '--uDir', type=str,
                        help='path to uDir (relative to tmp/ if testing)')

    parser.add_argument('-V', '--showVersion', action='store_true',
                        help='display version number and exit')

    parser.add_argument('-v', '--verbose', action='store_true',
                        help='be chatty')

    parser.add_argument('-X', '--exclusions', action='append',
                        help='do not include files/directories matching this pattern')

    args = parser.parse_args()

    if args.showVersion:
        print(APP_NAME)
        sys.exit(0)

    # fixups --------------------------------------------------------
    args.curDir = os.getcwd()

    if os.path.exists(args.ignoreFile):
        args.excl = getExclusions(args.curDir)
    else:
        print("WARNING: ignore file '%s' NOT FOUND" % args.ignoreFile)
        args.excl = []
    if not 'build' in args.excl:
        args.excl.append('build')

    if args.exclusions:
        args.excl.extend(args.exclusions)

    args.now = NOW

    if args.testing:
        args.dvczDir = os.path.join('tmp/dvcz')
        if os.path.exists(args.dvczDir):
            rm_f_dirContents(args.dvczDir)      # empties the directory
    os.makedirs(args.dvczDir, 0o755, exist_ok=True)
    # WE HAVE args.dvczDir

    # sanity checks -------------------------------------------------
    if not args.justShow:
        if not args.usingSHA1:
            print("can't handle SHA2 or SHA3 yet")
            sys.exit(1)

        if (not args.dataDir) or (args.dataDir == ''):
            print("no root directory specified")
            parser.print_usage()
            sys.exit(1)

        if not os.path.isdir(args.dataDir):
            print("root directory '%s' isn't a directory" % args.dataDir)
            parser.print_usage()        # short form
            # parser.print_help()       # long form (what you get from -h)
            sys.exit(1)

        if args.testing:
            args.keyFile = os.path.join(args.dvczDir, 'skPriv.pem')
        if not os.path.exists(args.keyFile):
            checkDirsInPath(args.keyFile)
            if args.testing:
                generateRSAKey(args.keyFile, 1024)
            else:
                generateRSAKey(args.keyFile, 2048)

    # uDir ------------------------------------------------
    if args.testing:
        if args.uDir:
            if args.uDir[0] == '/':
                args.uDir = args.uDir[1:]
            args.uDir = os.path.join('tmp', args.uDir)
            if os.path.exists(args.uDir):
                rm_f_dirContents(args.uDir)

    if args.uDir:
        os.makedirs(args.uDir, 0o755, exist_ok=True)

    # title -----------------------------------------------
    if args.dataDir:
        if not args.title or args.title == '':
            junk, sep, base = args.dataDir.rpartition('/')
            args.title = base
        else:
            # this can contain spaces and other undesirable characters
            base = args.title

    # complete setup ------------------------------------------------
    args.title = str(args.title)

    # maybe show options and such -----------------------------------
    if args.verbose or args.justShow:
        print("%s %s" % (APP_NAME, __version_date__))

    if args.verbose or args.justShow:
        print('dataDir      = ' + str(args.dataDir))
        print('dvczDir      = ' + str(args.dvczDir))
        print('excl         = ' + str(args.excl))
        print('exclusions   = ' + str(args.exclusions))
        print('ignoreFile   = ' + str(args.ignoreFile))
        print('justShow     = ' + str(args.justShow))
        print('keyFile      = ' + str(args.keyFile))
        print('listFile     = ' + str(args.listFile))
        print('logging      = ' + str(args.logging))
        print('timestamp    = ' + str(args.now))
        print('testing      = ' + str(args.testing))
        print('title        = ' + str(args.title))
        print('uDir         = ' + str(args.uDir))
        print('usingSHA1    = ' + str(args.usingSHA1))
        print('verbose      = ' + str(args.verbose))

        if args.matchPat and len(args.matchPat) > 0:
            print("match:")
            for match in args.matchPat:
                print("    %s" % match)

    if args.justShow:
        sys.exit(0)

    # do what's required --------------------------------------------

    # try: ACQUIRE LOCK ON PROJECT, that is, on the name of the project
    doit(args)

    # finally: RELEASE LOCK ON PROJECT

if __name__ == '__main__':
    main()
