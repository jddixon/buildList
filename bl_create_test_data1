#!/usr/bin/python3
from xlattice import Q
#
# ~/dev/py/buildlist/bl_create_test_data1

from argparse import ArgumentParser
import os
import shutil
import sys

from Crypto.PublicKey import RSA
from nlhtree import NLHTree
from xlattice.lfs import touch
from xlattice.util import make_ex_re
from rnglib import SimpleRNG
from xlattice import check_using_sha
from buildlist import __version__, __version_date__, BuildList

DEFAULT_OUT_DIR = '../../dat/xl_test_data/treeData/binExample_1'


def do_it(args):
    out_path = args.out_path
    if os.path.exists(out_path):
        print("deleting existing directory %s" % out_path)
        shutil.rmtree(out_path)
    # creates ../xl_test_data/treeData/binExample_1
    os.makedirs(out_path)

    # for using in [Q.USING_SHA1, Q.USING_SHA2, Q.USING_SHA3, ]:

    # NODE_DIR ------------------------------------------------------
    # Creates RSA key sk_priv and its public part sk; and writes
    # node/skPriv.pem.
    # ---------------------------------------------------------------
    out_path = args.out_path
    node_dir = os.path.join(out_path, 'node')
    os.makedirs(node_dir, mode=0o755)

    # should be >= 2048, but this is just testing
    sk_priv = RSA.generate(1024)
    path_to_key = os.path.join(node_dir, 'skPriv.pem')
    with open(path_to_key, 'wb') as file:
        file.write(sk_priv.exportKey('PEM'))
    sk_ = sk_priv.publickey()

    # DATA_DIR ------------------------------------------------------
    #
    # ---------------------------------------------------------------

    data_path = os.path.join(out_path, 'dataDir')
    sub_dir1 = os.path.join(data_path, 'subDir1')
    sub_dir2 = os.path.join(data_path, 'subDir2')
    sub_dir3 = os.path.join(data_path, 'subDir3')
    sub_dir4 = os.path.join(data_path, 'subDir4')
    sub_dir41 = os.path.join(sub_dir4, 'subDir41')
    sub_dir411 = os.path.join(sub_dir41, 'subDir411')

    for dir_name in [data_path, sub_dir1, sub_dir2, sub_dir3, sub_dir4,
                     sub_dir41, sub_dir411, ]:
        os.makedirs(dir_name, mode=0o755)

    # files to be populaed with random data
    rng = SimpleRNG()
    data1 = os.path.join(data_path, 'data1')
    data11 = os.path.join(sub_dir1, 'data11')
    data2 = os.path.join(data_path, 'data2')
    data31 = os.path.join(sub_dir3, 'data31')
    data4111 = os.path.join(sub_dir411, 'data31')

    for path in [data1, data11, data2, data31, data4111]:
        count = 16 + rng.nextInt16(2048)
        data = bytearray(count)
        rng.nextBytes(data)
        with open(path, 'wb') as file:
            file.write(data)

    # empty file(s)
    data12 = os.path.join(sub_dir1, 'data12')
    for path in [data12]:
        touch(path)

    # NLH_TREE ------------------------------------------------------
    #
    # ---------------------------------------------------------------
    nlh_path = os.path.join(out_path, 'nlhTree')

    for using_sha in [Q.USING_SHA1, Q.USING_SHA2, Q.USING_SHA3]:
        ndx = int(using_sha)
        ndx_path = os.path.join(nlh_path, str(ndx))
        os.makedirs(ndx_path, mode=0o755)
        tree = NLHTree.create_from_file_system(data_path, using_sha)

        u_path = os.path.join(ndx_path, 'u_dir')
        u_in = os.path.join(u_path, 'in')
        u_tmp = os.path.join(u_path, 'tmp')
        for dir_name in [u_path, u_in, u_tmp]:
            os.makedirs(dir_name, mode=0o755)
        tree.save_to_u_dir(data_path, u_path, using_sha)

    # BUILD LIST ----------------------------------------------------
    #
    # ---------------------------------------------------------------
    bl_path = os.path.join(out_path, 'buildlist')

    for using_sha in [Q.USING_SHA1, Q.USING_SHA2, Q.USING_SHA3]:
        ndx = int(using_sha)
        ndx_path = os.path.join(bl_path, str(ndx))
        os.makedirs(ndx_path, mode=0o755)

        list_file = os.path.join(ndx_path, 'example.bld')
        title = 'sample build list % d' % ndx
        ex_re = make_ex_re(['build', ])
        blist = BuildList.create_from_file_system(title, data_path, sk_, using_sha,
                                                  ex_re, match_re=None)
        blist.sign(sk_priv)
        bl_ser = blist.__str__()
        with open(list_file, 'w+') as file:
            file.write(bl_ser)

        # XXX MISSING: hex hash of BuildList

#       unmatched = bl.tree.check_in_u_dir(uPath)    # all leaf nodes present ?
#       if unmatched:
#           print("check walk on example %d failed" % ndx)
#           for u in unmatched:
#               print("  %s is not in uDir" % u)


def main():
    """
    Expect a command like
        bl_create_test_data1 [options]

    This program creates a quasi-random directory tree like

        ../xl_test_data/
            treeData
                binExample.1
                    node
                        skPriv.pem      # PEM serialization of private RSA key
                    dataDir/
                        data1
                        subDir1/
                            data11
                            data12      # empty
                        data2
                        subDir2/
                        subDir3/
                            data31
                        subDir4/
                            subDir41
                                subDir411
                                    data4111
                    nlhTree
                        {1,2,3}         # three subdirectories: 1/, 2/, 3/
                            example.nlh # serialization of NLHTree
                            uDir/
                                00/
                                ...
                                ff/
                                in/
                                tmp/
                    buildlist
                        {1,2,3}
                            example.bld     # serialized BuildList
                            hex             # BuildList.hash()
                    merkleTree
                        {1,2,3}
                            example.tree    # serialized
                            hex             # returned by merkleize -x


    sk_priv is the RSA private key used to sign the example.bld
    build list.

    The information under dataDir/ is a small directory tree.
    The data* are data files containing quasi-random data.  Both the
    file length and the contents are random.  data12 is an empty file.
    Subdirectory subDir2 is an empty subdirectory.

    example.bld is a build list for dataDir.  The build list contains
    the public part of the RSA key used to sign the list, its title,
    and a UTC timestamp, the time at which the list was signed.  The
    body of the list is an indented list of the files under dataDir/,
    with a line for each file, each line containing the SHA content
    hash of the document and its title.  The build list ends with a
    digital signature over the earlier part of the document.  In this
    example, the RSA private key used in signing the document in
    contained in node/sk_priv.

    nlhTree/{1,2,3}/uDir/ contains the same set of files as under dataDir/,
    but instead of being organized by name it is organized by content
    key, by the SHA{1,2,3} hash of the file, where SHA2 means SHA256
    and SHA3 means SHA3-256, the 256-bit version of Keccak.

    The notation '{1,2,3}' is an abbreviation for "each of the sequence
    of values 1, 2, and 3, taken in turn."

    The data under binExample.1/ is sufficient to verify the correctness of
    the build list and the 1-to-1 relationship between the files under
    binExample.1/datadir/ and those under binExample.1/nlhTree/{1,2,3}/uDir/

    For MerkleTrees, there are three serializations, indented lists
    created using SHA1, SHA2, and SHA3 under 1/, 2/, and 3 respectively;
    and also the value returned by merkleize -x, the hash value for the
    entire MerkleTree.
    """

    # parse the command line ----------------------------------------

    desc = 'generate a sample data tree, write a build list, and create a corresponding content-keyed store'

    parser = ArgumentParser(description=desc)

    parser.add_argument('-f', '--force', action='store_true',
                        help='overwrite any existing example/ directory')

    parser.add_argument('-j', '--justShow', action='store_true',
                        help='show options and exit')

    parser.add_argument('-o', '--out_path', default=DEFAULT_OUT_DIR,
                        help="example directory, defaults to '%s'" % DEFAULT_OUT_DIR)

    parser.add_argument('-v', '--verbose', action='store_true',
                        help='be chatty')

    args = parser.parse_args()

    # sanity chesks -------------------------------------------------
    if (not args.force) and os.path.exists(args.out_path):
        print(
            "target directory %s exists but force (-f) not specified" %
            args.out_path)
        parser.print_usage()
        sys.exit(1)

    # fixups --------------------------------------------------------

    # complete setup ------------------------------------------------
    app_name = 'bl_create_test_data1 %s' % __version__

    # maybe show options and such -----------------------------------
    if args.verbose or args.justShow:
        print("%s %s" % (app_name, __version_date__))

    if args.verbose or args.justShow:
        print('force        = ' + str(args.force))
        print('out_path     = ' + str(args.out_path))
        print('verbose      = ' + str(args.verbose))

    if args.justShow:
        sys.exit(0)

    # do what's required --------------------------------------------
    do_it(args)

if __name__ == '__main__':
    main()
