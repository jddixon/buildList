#!/usr/bin/python3
from xlattice import Q
#
# ~/dev/py/buildlist/bl_create_test_data1

import os
import re
import shutil
import sys

from argparse import ArgumentParser
from Crypto.PublicKey import RSA
from nlhtree import NLHLeaf, NLHTree
from xlattice.lfs import touch
from xlattice.util import make_ex_re
from rnglib import SimpleRNG
from xlattice import Q, check_using_sha

from buildlist import __file__, BuildList

DEFAULT_OUT_DIR = '../../dat/xl_test_data/treeData/binExample_1'


def do_it(args):
    out_path = args.out_path
    if os.path.exists(out_path):
        print("deleting existing directory %s" % out_path)
        shutil.rmtree(out_path)
    # creates ../xl_test_data/treeData/binExample_1
    os.makedirs(out_path)

    # for using in [Q.USING_SHA1, Q.USING_SHA2, Q.USING_SHA3, ]:

    # NODE_DIR ------------------------------------------------------
    # Creates RSA key skPriv and its public part sk; and writes
    # node/skPriv.pem.
    # ---------------------------------------------------------------
    out_path = args.out_path
    nodeDir = os.path.join(out_path, 'node')
    os.makedirs(nodeDir, mode=0o755)

    # should be >= 2048, but this is just testing
    skPriv = RSA.generate(1024)
    pathToKey = os.path.join(nodeDir, "skPriv.pem")
    with open(pathToKey, 'wb') as file:
        file.write(skPriv.exportKey('PEM'))
    sk = skPriv.publickey()

    # DATA_DIR ------------------------------------------------------
    #
    # ---------------------------------------------------------------

    dataPath = os.path.join(out_path, 'dataDir')
    subDir1 = os.path.join(dataPath, 'subDir1')
    subDir2 = os.path.join(dataPath, 'subDir2')
    subDir3 = os.path.join(dataPath, 'subDir3')
    subDir4 = os.path.join(dataPath, 'subDir4')
    subDir41 = os.path.join(subDir4, 'subDir41')
    subDir411 = os.path.join(subDir41, 'subDir411')

    for dVal in [dataPath, subDir1, subDir2, subDir3, subDir4,
                 subDir41, subDir411, ]:
        os.makedirs(dVal, mode=0o755)

    # files to be populaed with random data
    rng = SimpleRNG()
    data1 = os.path.join(dataPath, 'data1')
    data11 = os.path.join(subDir1, 'data11')
    data2 = os.path.join(dataPath, 'data2')
    data31 = os.path.join(subDir3, 'data31')
    data4111 = os.path.join(subDir411, 'data31')

    for path in [data1, data11, data2, data31, data4111]:
        count = 16 + rng.nextInt16(2048)
        data = bytearray(count)
        rng.nextBytes(data)
        with open(path, 'wb') as file:
            file.write(data)

    # empty file(s)
    data12 = os.path.join(subDir1, 'data12')
    for path in [data12]:
        touch(path)

    # NLH_TREE ------------------------------------------------------
    #
    # ---------------------------------------------------------------
    nlhPath = os.path.join(out_path, 'nlhTree')

    for using_sha in [Q.USING_SHA1, Q.USING_SHA2, Q.USING_SHA3]:
        ndx = int(using_sha)
        ndxPath = os.path.join(nlhPath, str(ndx))
        os.makedirs(ndxPath, mode=0o755)
        tree = NLHTree.create_from_file_system(dataPath, using_sha)

        u_path = os.path.join(ndxPath, 'u_dir')
        uIn = os.path.join(u_path, 'in')
        uTmp = os.path.join(u_path, 'tmp')
        for dVal in [u_path, uIn, uTmp]:
            os.makedirs(dVal, mode=0o755)
        tree.save_to_u_dir(dataPath, u_path, using_sha)

    # BUILD LIST ----------------------------------------------------
    #
    # ---------------------------------------------------------------
    blPath = os.path.join(out_path, 'buildlist')

    for using_sha in [Q.USING_SHA1, Q.USING_SHA2, Q.USING_SHA3]:
        ndx = int(using_sha)
        ndxPath = os.path.join(blPath, str(ndx))
        os.makedirs(ndxPath, mode=0o755)

        listFile = os.path.join(ndxPath, 'example.bld')
        title = 'sample build list % d' % ndx
        exRE = make_ex_re(['build', ])
        bl = BuildList.create_from_file_system(title, dataPath, sk, using_sha,
                                               exRE, matchRE=None)
        bl.sign(skPriv)
        blSer = bl.toString()
        with open(listFile, 'w+') as file:
            file.write(blSer)

        # XXX MISSING: hex hash of BuildList

#       unmatched = bl.tree.checkInUDir(uPath)    # all leaf nodes present ?
#       if unmatched:
#           print("check walk on example %d failed" % ndx)
#           for u in unmatched:
#               print("  %s is not in uDir" % u)


def main():
    """
    Expect a command like
        bl_create_test_data1 [options]

    This program creates a quasi-random directory tree like

        ../xl_test_data/
            treeData
                binExample.1
                    node
                        skPriv          # PEM serialization of private RSA key
                    dataDir/
                        data1
                        subDir1/
                            data11
                            data12      # empty
                        data2
                        subDir2/
                        subDir3/
                            data31
                        subDir4/
                            subDir41
                                subDir411
                                    data4111
                    nlhTree
                        {1,2,3}         # three subdirectories: 1/, 2/, 3/
                            example.nlh # serialization of NLHTree
                            uDir/
                                00/
                                ...
                                ff/
                                in/
                                tmp/
                    buildlist
                        {1,2,3}
                            example.bld     # serialized BuildList
                            hex             # BuildList.hash()
                    merkleTree
                        {1,2,3}
                            example.tree    # serialized
                            hex             # returned by merkleize -x


    skPriv is the RSA private key used to sign the example.bld
    build list.

    The information under dataDir/ is a small directory tree.
    The data* are data files containing quasi-random data.  Both the
    file length and the contents are random.  data12 is an empty file.
    Subdirectory subDir2 is an empty subdirectory.

    example.bld is a build list for dataDir.  The build list contains
    the public part of the RSA key used to sign the list, its title,
    and a UTC timestamp, the time at which the list was signed.  The
    body of the list is an indented list of the files under dataDir/,
    with a line for each file, each line containing the SHA content
    hash of the document and its title.  The build list ends with a
    digital signature over the earlier part of the document.  In this
    example, the RSA private key used in signing the document in
    contained in node/skPriv.

    nlhTree/{1,2,3}/uDir/ contains the same set of files as under dataDir/,
    but instead of being organized by name it is organized by content
    key, by the SHA{1,2,3} hash of the file, where SHA2 means SHA256
    and SHA3 means SHA3-256, the 256-bit version of Keccak.

    The notation '{1,2,3}' is an abbreviation for "each of the sequence
    of values 1, 2, and 3, taken in turn."

    The data under binExample.1/ is sufficient to verify the correctness of
    the build list and the 1-to-1 relationship between the files under
    binExample.1/datadir/ and those under binExample.1/nlhTree/{1,2,3}/uDir/

    For MerkleTrees, there are three serializations, indented lists
    created using SHA1, SHA2, and SHA3 under 1/, 2/, and 3 respectively;
    and also the value returned by merkleize -x, the hash value for the
    entire MerkleTree.
    """

    __version__ = re.search("__version__\s*=\s*'(.*)'",
                            open(__file__).read()).group(1)
    __version_date__ = re.search("__version_date__\s*=\s*'(.*)'",
                                 open(__file__).read()).group(1)

    # parse the command line ----------------------------------------

    DESC = 'generate a sample data tree, write a build list, and create a corresponding content-keyed store'

    parser = ArgumentParser(description=DESC)

    parser.add_argument('-f', '--force', action='store_true',
                        help='overwrite any existing example/ directory')

    parser.add_argument('-j', '--justShow', action='store_true',
                        help='show options and exit')

    parser.add_argument('-o', '--outPath', default=DEFAULT_OUT_DIR,
                        help="example directory, defaults to '%s'" % DEFAULT_OUT_DIR)

    parser.add_argument('-v', '--verbose', action='store_true',
                        help='be chatty')

    args = parser.parse_args()

    # sanity chesks -------------------------------------------------
    if (not args.force) and os.path.exists(args.out_path):
        print(
            "target directory %s exists but force (-f) not specified" %
            args.out_path)
        parser.print_usage()
        sys.exit(1)

    # fixups --------------------------------------------------------

    # complete setup ------------------------------------------------
    appName = 'bl_create_test_data1 %s' % __version__

    # maybe show options and such -----------------------------------
    if args.verbose or args.justShow:
        print("%s %s" % (appName, __version_date__))

    if args.verbose or args.justShow:
        print('force        = ' + str(args.force))
        print('outPath      = ' + str(args.out_path))
        print('verbose      = ' + str(args.verbose))

    if args.justShow:
        sys.exit(0)

    # do what's required --------------------------------------------
    do_it(args)

if __name__ == '__main__':
    main()
